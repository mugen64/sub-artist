/**
 * Contains Subtitle Logic
 */
export default (moment) => {
  // Todo move this time logic to a file detected to to time some >>>time<<<
  const timeFormats = {
    // for now since we only need webVttTime
    webVttTime: 'hh:mm:ss.SSS'
  };
  return {
    /**
     * Format from Time in float to a new format
     * @param {Float} timeInFloat
     * @param {String} timeUnits
     * @param {String} formatUsed
     * @param {Boolean} trim
     * @return {String}
     */
    formatDurationFromFloat(
      timeInFloat,
      timeUnits = 'seconds',
      formatUsed = 'webVttTime',
      trim = false
    ) {
      return moment
        .duration(timeInFloat, timeUnits)
        .format(timeFormats[formatUsed], { trim });
    },
    fromFormattedDurationToFloat(
      formattedTime,
      formatUsed = 'webVttTime',
      timeUnits = 'seconds'
    ) {
      // const f = timeFormats[formatUsed];
      // return moment(formattedTime, f).diff(
      //   moment(this.formatDurationFromFloat(0, timeUnits, formatUsed), f),
      //   timeUnits
      // );
      // for now manually
      if (!formattedTime) return 0;
      const parts = formattedTime.split(':');
      let duration = +parts[0] * 60 * 60;
      duration += +parts[1] * 60;
      duration += +parts[2];
      return duration;
    },
    /**
     * Check if time of interest is between a times a and b
     * where a < b
     * @param {String} timeOfInterest
     * @param {String} timeA
     * @param {String} timeB
     * @param {String} formatUsed
     * @return {Boolean}
     */
    isTimeBetween(timeOfInterest, timeA, timeB, formatUsed = 'webVttTime') {
      const f = timeFormats[formatUsed];
      return moment(timeOfInterest, f).isBetween(
        moment(timeA, f),
        moment(timeB, f)
      );
    },

    /**
     * Check if time of interest is before time b
     * @param {String} timeOfInterest
     * @param {String} timeB
     * @param {String} formatUsed
     * @return {Boolean}
     */
    isTimeBefore(timeOfInterest, timeB, formatUsed = 'webVttTime') {
      const f = timeFormats[formatUsed];
      return moment(timeOfInterest, f).isBefore(moment(timeB, f));
    },
    /**
     * Generate WebVtt From array of cues
     * @param {Array} subtitles
     * @return {String}
     */
    generateWebVttTextFromObjArray(
      subtitles,
      comment = 'Subtitles Generated by Sub Artist'
    ) {
      let content = 'WEBVTT - ' + comment;
      content += '\n\n';
      if (subtitles.length > 0) {
        subtitles.forEach((sub, idx) => {
          content += '\n';
          content += idx + 1;
          content += '\n';
          content += sub.start + ' --> ' + sub.end;
          content += '\n';
          content += sub.text || '[Generated by Sub Artist]';
          content += '\n';
        });
      }
      return content;
    },

    generateObjArrayFromWebVttText(text) {
      const subtitles = [];
      // split by line
      const content = (text || '').split('\n');
      // get the index of first cue
      const idxOfFirstCue = content.findIndex((v) => {
        if (v.length <= 0) return false;
        return !isNaN(v.charAt(0));
      });
      // if we find a cue
      if (idxOfFirstCue > -1) {
        for (let index = idxOfFirstCue + 1; index < content.length; index++) {
          let timestep = content[index];
          while (timestep.length < 1 && index < content.length) {
            timestep = content[index];
            index++;
          }
          if (index === content.length) break;
          const idxOfArrow = timestep.lastIndexOf('>');
          index++;
          if (index === content.length) break;
          const text = content[index];
          subtitles.push({
            start: timestep.substring(0, idxOfArrow - 3),
            end: timestep.substring(idxOfArrow + 2),
            text
          });
          index++; // move from test line to next
          // go to next
          while (index < content.length && content[index].length < 1) {
            index++;
          }
          while (index < content.length && isNaN(content[index].charAt(0))) {
            index++;
          }
          // console.log(this.subtitles);
          if (index === content.length) break;
        }
      }
      return subtitles;
    }
  };
};
